{"version":3,"sources":["webpack://uploader/webpack/universalModuleDefinition","webpack://uploader/./src/index.js","webpack://uploader/./src/upload/index.js","webpack://uploader/./src/upload/resume.js","webpack://uploader/./src/utils.js","webpack://uploader/./node_modules/spark-md5/spark-md5.js","webpack://uploader/./src/api.js","webpack://uploader/./src/upload/base.js","webpack://uploader/./src/pool.js","webpack://uploader/./src/upload/direct.js","webpack://uploader/./src/observable.js","webpack://uploader/webpack/bootstrap","webpack://uploader/webpack/runtime/compat get default export","webpack://uploader/webpack/runtime/define property getters","webpack://uploader/webpack/runtime/hasOwnProperty shorthand","webpack://uploader/webpack/runtime/make namespace object","webpack://uploader/webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;ACV2C;AACD;;AAE1C;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAmB;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,mDAAU;AACvB;;AAEA,iEAAe,MAAM,E;;;;;;;;;;;;;;;;AC9BS;AACA;AACA;AACP;AACE;;AAEV;AACf;AACA;AACA;AACA,iBAAiB,4CAAM;AACvB;AACA;AACA;AACA,eAAe,4CAAM;AACrB;AACA;AACA,iCAAiC,sCAAE;AACnC,YAAY,4CAAM;AAClB,YAAY,4CAAM;AAClB,C;;;;;;;;;;;;;;;ACpBkC;AAGjB;AAGD;AACU;AAC1B;AACA;AACA;AACA;AACA;;AAEe,qBAAqB,0CAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,uCAAI;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,uDAAyB;AAC/B,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,oDAAsB;AAC1B;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAsB;AAC5C;AACA;AACA;AACA;AACA,MAAM,uDAAyB;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,kDAAoB;AAC/B;;AAEA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAS;AAC5B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;AC9OiC;AAC1B;AACP;AACO;AACP,qCAAqC;AACrC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;;AAGO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACO;AACP,+CAA+C,IAAI;AACnD,mCAAmC,KAAK,EAAE,SAAS,OAAO,KAAK;AAC/D;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA,oBAAoB,8DAAoB;AACxC;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,UAAU;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA,C;;;;;;ACvLA;AACA,QAAQ,IAA2B;AACnC;AACA;AACA,KAAK,MAAM,aAcN;AACL,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC9uBgC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB,kCAAkC;AAC/D;AACA,SAAS,2CAAa,oCAAoC;AAC1D;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,mCAAmC;AACnE,SAAS,2CAAa;AACtB;AACA,GAAG;AACH,C;;;;;;;;;;;;AC5BO,6BAA6B;AACpC;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,E;;;;;;;;;;;ACtJZ;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,C;;;;;;;;;;;;;AC3CkB;AACQ;;AAE1B,qBAAqB,0CAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAO;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,MAAM,E;;;;;;;;;;;;AC3DrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qBAAqB,uBAAuB,aAAa,QAAQ,gBAAgB,WAAW;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;UCvEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"upload.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"uploader\"] = factory();\n\telse\n\t\troot[\"uploader\"] = factory();\n})(self, function() {\nreturn ","import createUploadManager from './upload';\nimport { Observable } from './observable';\n\n/**\n * 返回一个上传Observable对象\n * @param {File} params0.file 需要上传的文件\n * @param {string} params0.key 上传文件的唯一标识\n * @param {object} params0.config 上传配置\n */\nfunction upload({file, key, config, customVars, putExtra}) {\n  const options = {\n    file,\n    key,\n    config,\n    customVars,\n    putExtra,\n  }\n  const createManager = (observer) => {\n    const manager = createUploadManager(options, {\n        onData: (data) => observer.next(data),\n        onError: (err) => observer.error(err),\n        onComplete: (res) => observer.complete(res)\n    });\n    manager.putFile();\n    return manager.stop.bind(manager);\n  };\n\n  return new Observable(createManager);\n}\n\nexport default upload;","import Resume from './resume';\nimport Direct from './direct';\nimport { MB } from '../utils';\nexport * from './base';\nexport * from './resume';\n\nexport default function createUploadManager(options, handlers) {\n  // config.forceDirect: \n  // 是否上传全部采用直传方式，为布尔值；为 `true` 时则上传方式全部为直传 form 方式，禁用断点续传，默认 `false`。\n  if (options.config && options.config.forceDirect) {\n      return new Direct(options, handlers);\n  }\n  // 是否强制为分片模式，如果是则不进行判断，直接使用分片上传\n  if(options.config && options.config.forceResume) {\n    return new Resume(options, handlers);\n  }\n  // 如果大于4MB则分片，否则直传\n  return options.file.size > 4 * MB\n      ? new Resume(options, handlers)\n      : new Direct(options, handlers);\n}","import * as utils from '../utils';\nimport {\n  Pool\n} from '../pool';\nimport {\n  uploadChunk,\n} from '../api';\nimport Base from './base';\n/** 是否为正整数 */\nfunction isPositiveInteger(n) {\n  var re = /^[1-9]\\d*$/;\n  return re.test(String(n));\n}\n\nexport default class Resume extends Base {\n  // 开始分片上传\n  async run() {\n    // 判断分片大小是否正确\n    if (!this.config.chunkSize || !isPositiveInteger(this.config.chunkSize)) {\n      throw new Error('chunkSize must be a positive integer');\n    }\n    // 单片大小最大为1G\n    if (this.config.chunkSize > 1024) {\n      throw new Error('chunkSize maximum value is 1024');\n    }\n\n    // 初始化工作，初始化进度、分片数据、上传文件信息等\n    await this.initBeforeUploadChunks();\n\n    // 创建上传池，池最大数量为并发数，默认为3，通过options.config.concurrentRequestLimit自定义，当不应该设置过大，跟浏览器的并发请求数相关\n    // pool.__proto__.constructor(runTask, limit)，创建pool对象\n    // 注意这里的箭头函数，所以this指的是Resume对象总的this.uploadChunk()方法\n    const pool = new Pool((chunkInfo) => this.uploadChunk(chunkInfo), this.config.concurrentRequestLimit);\n    // 生成上传分片任务，遍历分片，把分片任务入队，返回promise数组\n    const uploadChunks = this.chunks.map((chunk, index) => pool.enqueue({\n      chunk,\n      index\n    }));\n    // 执行任务promise，promise任务包括push task，以及执行pool.check(）\n    // pool.check() 判断当前是否有空闲“线程”，如果有则执行pool.run()\n    // pool.run() 执行栈:\n    // [pool.runTask, resume.uploadChunk(), resume.updateChunkProgress(), utils.computeMd5(), \n    // resume.updateChunkProgress(), api.uploadChunk(), resume.updateChunkProgress(), utils.setLocalFileInfo()]\n    // 当pool.runTask()出栈后，则执行 pool.resolve()方法，该item执行完毕，继续调用pool.check()方法，知道Promise.all()中promise全部完成\n    // 该方法未异步执行，入栈后，执行下一行\n    const result = Promise.all(uploadChunks).then(() => this.updateMkFileProgress(1));\n\n    // 该行代码为result的链式then方法，入微任务队列，执行下一行代码\n    // 开始进行上传请求，完成上传后执行清理工作\n    result.then(() => {\n      // 清除本地上传缓存信息\n      utils.removeLocalFileInfo(this.getLocalKey());\n    }, err => {\n      console.warn(err);\n    });\n\n    // 返回上传任务结果<promise.all>\n    return result;\n  }\n\n  // 上传\n  async uploadChunk(chunkInfo) {\n    const {\n      index,\n      chunk\n    } = chunkInfo;\n    const info = this.uploadedList[index];\n    const shouldCheckMD5 = this.config.checkByMD5;\n    // 使用已有缓存\n    const reuseSaved = () => {\n      this.updateChunkProgress(chunk.size, index);\n    };\n    if (info && !shouldCheckMD5) {\n      reuseSaved();\n      return;\n    }\n    // 只有需要md5检查才计算\n    if(shouldCheckMD5) {\n      const md5 = await utils.computeMd5(chunk);\n      if (info && md5 === info.md5) {\n        reuseSaved();\n        return;\n      }\n    }\n    const onProgress = (data) => {\n      this.updateChunkProgress(data.loaded, index);\n    };\n    const formdata = this.getUploadChunkFormData({chunk, index});\n    const requestOptions = {\n      body: formdata,\n      headers: this.config.chunkHeaders,\n      onProgress,\n      onCreate: (xhr) => this.addXhr(xhr),\n      requestIdField: this.config.requestIdField,\n    };\n    const response = await uploadChunk(\n      {\n        key: this.key,\n        options: requestOptions,\n        method: this.config.uploadChunkMethod,\n        url: this.config.path,\n        uploadInfo: this.getUploadInfo(),\n        index: chunkInfo.index,\n      }\n    );\n    // 在某些浏览器环境下，xhr 的 progress 事件无法被触发，progress 为 null，这里在每次分片上传完成后都手动更新下 progress\n    onProgress({\n      loaded: chunk.size,\n      total: chunk.size\n    });\n    this.uploadedList[index] = {\n      etag: response.data.etag,\n      md5: response.data.md5,\n      size: chunk.size\n    };\n    utils.setLocalFileInfo(this.getLocalKey(), {\n      id: this.uploadId,\n      data: this.uploadedList\n    });\n  }\n\n  /**\n   * 上传前文件处理，设置分片信息\n   */\n  async initBeforeUploadChunks() {\n    const localKey = this.getLocalKey();\n    // 获取本地标识对象\n    const localInfo = utils.getLocalFileInfo(localKey);\n    // 分片必须和当时使用的 uploadId 配套，所以断点续传需要把本地存储的 uploadId 拿出来\n    // 假如没有 localInfo 本地信息并重新获取 uploadId\n    if (!localInfo) {\n      // 防止本地信息已被破坏，初始化时 clear 一下\n      utils.removeLocalFileInfo(localKey);\n      // 本地信息损坏和移除了，uploadId直接使用生成的缓存key，已上传分片列表数据为空\n      this.uploadId = localKey;\n      this.uploadedList = [];\n    } else {\n      // 如果本地已有缓存（断点续传的本地缓存判断），则uploadId为缓存信息的id，已上传分片列表为data\n      this.uploadId = localInfo.id;\n      this.uploadedList = localInfo.data;\n    }\n    // 获取文件分片大小\n    this.chunks = utils.getChunks(this.file, this.config.chunkSize);\n    // 初始化上传信息进度，mkFileProgress 标记是否已完成，未完成时为0，已完成后设置为1， chunks 每个分片的已上传文件大小\n    this.loaded = {\n      mkFileProgress: 0, // 值为0或者1，上传完成时会被设置为1\n      chunks: this.chunks.map(_ => 0)\n    };\n    // 更新\n    this.notifyResumeProgress();\n  }\n\n\n  /**\n   * 返回当前上传文件的uploadId和uploadUrl\n   */\n  getUploadInfo() {\n    return {\n      id: this.uploadId,\n      url: this.uploadUrl\n    };\n  }\n\n  /**\n   * 获取文件唯一标识信息，通过文件名称，唯一标识和大小来生成\n   */\n  getLocalKey() {\n    return utils.createLocalKey(this.file.name, this.key, this.file.size);\n  }\n\n  /**\n   * 更新分片上传进度数据\n   * @param {*} loaded 分片已上传大小\n   * @param {*} index 分片索引\n   */\n  updateChunkProgress(loaded, index) {\n    this.loaded.chunks[index] = loaded;\n    this.notifyResumeProgress();\n  }\n\n  /**\n   * 上传完成，设置mkFileProgress为1\n   * @param {*} progress \n   */\n  updateMkFileProgress(progress) {\n    this.loaded.mkFileProgress = progress;\n    this.notifyResumeProgress();\n  }\n\n  /**\n   * 通知更新上传进度\n   * getProgressInfoItem 方法来自base\n   */\n  notifyResumeProgress() {\n    // utils.sum(this.loaded.chunks) 求每一个分片已上传大小之和\n    // this.loaded.mkFileProgress 上传中 = 0， 上传完成 = 1 , 也就是上传过程中，总不会达到100%，上传结束，文件大小已+1，则正确情况为100%\n    // loaded 上传中为所有分片已上传之和，如果上传完成后则为上传分片大小之和+1\n    const loaded = utils.sum(this.loaded.chunks) + this.loaded.mkFileProgress;\n    // 文件大小 + 1\n    const size = this.file.size + 1;\n    this.progress = {\n      // 整体上传进度，返回{loaded, size, percent: loaded / size * 100}\n      total: this.getProgressInfoItem(loaded, size),\n      // 每一个chunk的上传进度，[]\n      chunks: this.chunks.map((chunk, index) => (this.getProgressInfoItem(this.loaded.chunks[index], chunk.size))),\n      // 上传信息\n      uploadInfo: {\n        id: this.uploadId,\n        url: this.uploadUrl\n      }\n    };\n    // 调用onData回调函数, onData  继承自base, 来源于用户传入的handlers的onData\n    this.onData(this.progress);\n  }\n\n\n  getUploadChunkFormData({chunk, index}) {\n    const formdata = new FormData();\n    if(this.customVars) {\n      for (const key in this.customVars) {\n        const value = this.customVars[key];\n        formdata.append(key, value);\n      }\n    }\n    const fields = this.putExtraFields;\n    fields.forEach(field => {\n      if(field && this.getPutExtraField(field)) {\n        if(field === 'file') {\n          formdata.append(this.getPutExtraField(field), chunk);\n        }else if(field === 'chunkIndex') {\n          formdata.append(this.getPutExtraField(field), index);\n        }else{\n          formdata.append(this.getPutExtraField(field), this.getPutExtraData(field));\n        }\n      }\n    });\n    return formdata;\n  }\n}","import SparkMD5 from 'spark-md5';\nexport const MB = 1024 ** 2;\n// 文件分块\nexport function getChunks(file, blockSize) {\n  let chunkByteSize = blockSize * MB; // 转换为字节\n  // 如果 chunkByteSize 比文件大，则直接取文件的大小\n  if (chunkByteSize > file.size) {\n    chunkByteSize = file.size;\n  } else {\n    // 因为最多 10000 chunk，所以如果 chunkSize 不符合则把每片 chunk 大小扩大两倍\n    while (file.size > chunkByteSize * 10000) {\n      chunkByteSize *= 2;\n    }\n  }\n  const chunks = [];\n  const count = Math.ceil(file.size / chunkByteSize);\n  for (let i = 0; i < count; i++) {\n    // chunk: 一个新的 Blob 对象，它包含了原始 Blob 对象的某一个段的数据。\n    const chunk = file.slice(chunkByteSize * i, i === count - 1 ? file.size : chunkByteSize * (i + 1));\n    chunks.push(chunk);\n  }\n  return chunks;\n}\n\nexport function sum(list) {\n  return list.reduce((data, loaded) => data + loaded, 0);\n}\n\n\nexport function setLocalFileInfo(localKey, info) {\n  try {\n    // 用于浏览器缓存文件分片信息，方便续传\n    localStorage.setItem(localKey, JSON.stringify(info));\n  } catch (err) {\n    if (window.console && window.console.warn) {\n      // eslint-disable-next-line no-console\n      console.warn('setLocalFileInfo failed');\n    }\n  }\n}\n\n/**\n * 根据文件名称，key和大小，生成文件信息缓存在本地的key字符串\n * @param {*} name 文件名称\n * @param {*} key 文件唯一标识\n * @param {*} size 文件大小\n */\nexport function createLocalKey(name, key, size) {\n  const localKey = key == null ? '_' : `_key_${key}_`;\n  return `split_upload_file_name_${name}${localKey}size_${size}`;\n}\n\n/**\n * 当文件信息无效时，直接移除localStorage中对应的item\n * @param {stirng} localKey 文件缓存key\n */\nexport function removeLocalFileInfo(localKey) {\n  try {\n    localStorage.removeItem(localKey);\n  } catch (err) {\n    if (window.console && window.console.warn) {\n      // eslint-disable-next-line no-console\n      console.warn('removeLocalFileInfo failed');\n    }\n  }\n}\n\n/**\n * 返回通过createLocalKey方法生成的key对应的保存在localStorage中的发序列化（JSON.parse）后的文件信息\n * @param {*} localKey 本地标识key\n */\nexport function getLocalFileInfo(localKey) {\n  try {\n    const localInfo = localStorage.getItem(localKey);\n    return localInfo ? JSON.parse(localInfo) : null;\n  } catch (err) {\n    if (window.console && window.console.warn) {\n      // eslint-disable-next-line no-console\n      console.warn('getLocalFileInfo failed');\n    }\n    return null;\n  }\n}\n\nexport function createXHR() {\n  if (window.XMLHttpRequest) {\n    return new XMLHttpRequest();\n  }\n  return window.ActiveXObject('Microsoft.XMLHTTP');\n}\n\n\nexport async function computeMd5(data) {\n  const buffer = await readAsArrayBuffer(data);\n  const spark = new SparkMD5.ArrayBuffer();\n  spark.append(buffer);\n  return spark.end();\n}\n\n\nexport function readAsArrayBuffer(data) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    // evt 类型目前存在问题 https://github.com/Microsoft/TypeScript/issues/4163\n    reader.onload = (evt) => {\n      if (evt.target) {\n        const body = evt.target.result;\n        resolve(body);\n      } else {\n        reject(new Error('progress event target is undefined'));\n      }\n    };\n    reader.onerror = () => {\n      reject(new Error('fileReader read failed'));\n    };\n    reader.readAsArrayBuffer(data);\n  });\n}\n\n/**\n * \n * @param {String} url \n * @param {Object} options {method, onCreate, headers, onProgress, body, requestIdField}\n */\nexport function request(url, options) {\n  const requestIdField = options.requestIdField || 'requestId';\n  return new Promise((resolve, reject) => {\n    const xhr = createXHR();\n    xhr.open(options.method, url);\n    if (options.onCreate) {\n      options.onCreate(xhr);\n    }\n    if (options.headers) {\n      const headers = options.headers;\n      Object.keys(headers).forEach(k => {\n        xhr.setRequestHeader(k, headers[k]);\n      });\n    }\n\n    xhr.upload.addEventListener('progress', (evt) => {\n      if (evt.lengthComputable && options.onProgress) {\n        options.onProgress({\n          loaded: evt.loaded,\n          total: evt.total\n        });\n      }\n    });\n\n    xhr.onreadystatechange = () => {\n      const responseText = xhr.responseText;\n      if (xhr.readyState !== 4) {\n        return;\n      }\n      const reqId = xhr.getResponseHeader(requestIdField) || '';\n      if (xhr.status !== 200) {\n        let message = `xhr request failed, code: ${xhr.status}`;\n        if (responseText) {\n          message += ` response: ${responseText}`;\n        }\n        reject({\n          code: xhr.status,\n          message,\n          reqId,\n          isRequestError: true\n        });\n        return;\n      }\n      try {\n        resolve({\n          data: JSON.parse(responseText),\n          reqId\n        });\n      } catch (err) {\n        reject(err);\n      }\n    };\n    xhr.send(options.body);\n  });\n}\n\nexport function createObjectURL(file) {\n  const URL = window.URL || window.webkitURL || window.mozURL;\n  return URL.createObjectURL(file);\n}","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash.slice()\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} [raw] True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n","import * as utils from './utils';\n\n/**\n * @param key 文件本地缓存key\n * @param index 当前 chunk 的索引\n * @param uploadInfo 上传信息\n * @param options 请求参数\n * @param method 请求方法\n */\nexport function uploadChunk({options, method = 'PUT', url = ''}) {\n  // 上传分片\n  return utils.request(url, Object.assign(Object.assign({}, options), {\n    method,\n    headers: Object.assign({\n      'Content-type': 'multipart/form-data'\n    }, options.headers)\n  }));\n}\n/**\n * @param key 目标文件名\n * @param uploadInfo 上传信息\n * @param options 请求参数\n * @param method 请求方法\n */\nexport function uploadComplete({options, method = 'POST', url = ''}) {\n  return utils.request(url, Object.assign({\n    method,\n  }, options));\n}","export const DEFAULT_CHUNK_SIZE = 4; // 单位 MB\nconst GB = 1024 ** 3;\n\nconst putExtraMethods = {\n  fileName: function() {\n    return this.file && this.file.name;\n  },\n  fileSize: function() {\n    return this.file && this.file.size;\n  },\n  fileKey: function() {\n    return this.getLocalKey();\n  },\n  chunkSize: function() {\n    return this.config.chunkSize * 1024**2;\n  },\n  totalChunksCount: function() {\n    return this.chunks && this.chunks.length;\n  },\n  chunkIndex: function() {\n    console.warn('无法通过该方法获取chunkIndex，请直接在uploadchunk方法中获取');\n  },\n  file: function() {\n    console.warn('无法通过该方法获取file, 请直接在uploadChunk方法中获取');\n  }\n};\n\nconst putExtraFiled = {\n  file: function() {\n    return this.putExtra && this.putExtra.file || '';\n  },\n  fileName: function() {\n    return this.putExtra && this.putExtra.fileName || '';\n  },\n  fileSize: function() {\n    return this.putExtra && this.putExtra.fileSize || '';\n  },\n  fileKey: function() {\n    return this.putExtra && this.putExtra.fileKey || '';\n  },\n  chunkSize: function() {\n    return this.putExtra && this.putExtra.chunkSize || '';\n  },\n  totalChunksCount: function() {\n    return this.putExtra && this.putExtra.totalChunksCount || '';\n  },\n  chunkIndex: function() {\n    return this.putExtra && this.putExtra.chunkIndex || '';\n  },\n};\n\nclass Base {\n  constructor(options, handlers) {\n    this.xhrList = [];\n    this.aborted = false;\n    this.retryCount = 0;\n    this.config = Object.assign({\n      path: '', // 上传请求url\n      uploadChunkMethod: 'PUT',\n      uploadCompleteMethod: 'POST',\n      chunkHeaders: {}, // 上传分片时的headers配置\n      mkHeaders: {},    // 上传完成请求的headers\n      requestIdField: 'requestId', // 上传请求响应头中返回的请求id字段\n      retryCount: 3,\n      checkByMD5: false,\n      forceDirect: false,\n      forceResume: false,\n      chunkSize: DEFAULT_CHUNK_SIZE,\n      concurrentRequestLimit: 3 // 请求并发数\n    }, options.config);\n    this.customVars = options.customVars;\n    this.putExtraFields = ['fileName', 'fileSize', 'fileKey', 'chunkSize', 'totalChunksCount', 'chunkIndex', 'file'];\n    this.putExtra = options.putExtra;\n    this.file = options.file;\n    this.key = options.key; // 上传文件的唯一标识\n    this.onData = handlers.onData;\n    this.onError = handlers.onError;\n    this.onComplete = handlers.onComplete;\n  }\n\n  getPutExtraData(field) {\n    const extrafield = field && putExtraFiled[field].call(this);\n    return extrafield && putExtraMethods[field] && putExtraMethods[field].call(this) || '';\n  }\n\n  getPutExtraField(field) {\n    return putExtraFiled[field].call(this);\n  }\n\n  async putFile() {\n    this.aborted = false;\n    if (this.file.size > 10000 * GB) {\n      const err = new Error('file size exceed maximum value 10000G');\n      this.onError(err);\n      throw err;\n    }\n    try {\n      // 获取上传文件请求url\n      this.uploadUrl = this.config.path;\n      this.uploadAt = new Date().getTime();\n      // 开始上传文件，调用run()方法，run方法不在base类中定义，在Direct和Resume类中实现\n      const result = await this.run();\n      // 调用完成handler回调函数\n      this.onComplete(result.data);\n      // 返回上传结果\n      return result;\n    } catch (err) {\n      this.clear();\n\n      const needRetry = err.isRequestError && err.code === 0 && !this.aborted;\n      const notReachRetryCount = ++this.retryCount <= this.config.retryCount;\n      // 以下条件满足其中之一则会进行重新上传：\n      // 1. 满足 needRetry 的条件且 retryCount 不为 0\n      // 2. uploadId 无效时在 resume 里会清除本地数据，并且这里触发重新上传\n      if (needRetry && notReachRetryCount || err.code === 612) {\n        // 重试\n        return this.putFile();\n      }\n      this.onError(err);\n      throw err;\n    }\n  }\n  clear() {\n    // 中断所有请求，并清空队列\n    this.xhrList.forEach(xhr => xhr.abort());\n    this.xhrList = [];\n  }\n  stop() {\n    // 停止上传，清空并设置中断状态\n    this.clear();\n    this.aborted = true;\n  }\n  addXhr(xhr) {\n    // 入请求队列\n    this.xhrList.push(xhr);\n  }\n\n  /**\n   * 获取进度\n   * @param {number} loaded 已上传大小\n   * @param {number} size 总大小\n   */\n  getProgressInfoItem(loaded, size) {\n    return {\n      loaded,\n      size,\n      percent: loaded / size * 100\n    };\n  }\n}\nexport default Base;","export class Pool {\n  constructor(runTask, limit) {\n    this.runTask = runTask;\n    this.limit = limit;\n    this.queue = [];\n    this.processing = [];\n  }\n\n  // 上传任务入队列，任务属性包含任务，resolve回调函数和reject回调函数\n  enqueue(task) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        task,\n        resolve,\n        reject\n      });\n      this.check();\n    });\n  }\n\n  // 执行队列任务\n  run(item) {\n    // 更新队列数据，疑问：为什么要用filter而不是直接splice？是因为复制比移动消耗更少？\n    this.queue = this.queue.filter(v => v !== item);\n    // 添加item到处理中的队列\n    this.processing.push(item);\n    // 执行任务\n    this.runTask(item.task).then(() => {\n      // 任务执行完成后， 更新\n      this.processing = this.processing.filter(v => v !== item);\n      // 调用item的resolve\n      item.resolve();\n      this.check();\n    }, err => item.reject(err));\n  }\n\n  // 检查队列状态，继续执行队列任务\n  check() {\n    const processingNum = this.processing.length;\n    const availableNum = this.limit - processingNum;\n    // 获取限制数量内可执行的任务，limit减去目前还在执行中的任务数量\n    this.queue.slice(0, availableNum).forEach(item => {\n      this.run(item);\n    });\n  }\n}","import {\n  request\n} from '../utils';\nimport Base from './base';\n\nclass Direct extends Base {\n  // 开始上传文件\n  async run() {\n    const formData = new FormData();\n    if (this.customVars) {\n      const customVars = this.customVars;\n      Object.keys(customVars).forEach(key => formData.append(key, customVars[key]));\n    }\n    const result = await request(this.uploadUrl, {\n      method: 'POST',\n      body: formData,\n      onProgress: data => {\n        this.updateDirectProgress(data.loaded, data.total);\n      },\n      onCreate: xhr => this.addXhr(xhr),\n      requestIdField: this.config.requestIdField,\n    });\n    this.finishDirectProgress();\n    return result;\n  }\n\n  // 更新上传进度\n  updateDirectProgress(loaded, total) {\n    // 当请求未完成时可能进度会达到100，所以total + 1来防止这种情况出现\n    // 返回{loaded, size, percent}\n    this.progress = {\n      total: this.getProgressInfoItem(loaded, total + 1)\n    };\n    // 调用onData回调函数\n    this.onData(this.progress);\n  }\n\n  // 完成上传\n  finishDirectProgress() {\n    // 在某些浏览器环境下，xhr 的 progress 事件无法被触发，progress 为 null，这里 fake 下\n    if (!this.progress) {\n      this.progress = {\n        total: this.getProgressInfoItem(this.file.size, this.file.size)\n      };\n      // 调用onData回调函数\n      this.onData(this.progress);\n      return;\n    }\n    const {\n      total\n    } = this.progress;\n    this.progress = {\n      total: this.getProgressInfoItem(total.loaded + 1, total.size)\n    };\n    // 调用onData回调函数\n    this.onData(this.progress);\n  }\n}\n\nexport default Direct;","/** 表示可清理的资源，比如 Observable 的执行 */\nclass Subscription {\n  constructor() {\n      /** 用来标示该 Subscription 是否被取消订阅的标示位 */\n      this.closed = false;\n  }\n  /** 取消 observer 的订阅 */\n  unsubscribe() {\n      if (this.closed) {\n          return;\n      }\n      this.closed = true;\n      if (this._unsubscribe) {\n          this._unsubscribe();\n      }\n  }\n  /** 添加一个 tear down 在该 Subscription 的 unsubscribe() 期间调用 */\n  add(teardown) {\n      this._unsubscribe = teardown;\n  }\n}\n/**\n* 实现 Observer 接口并且继承 Subscription 类，Observer 是消费 Observable 值的公有 API\n* 所有 Observers 都转化成了 Subscriber，以便提供类似 Subscription 的能力，比如 unsubscribe\n*/\nexport class Subscriber extends Subscription {\n  constructor(observerOrNext, error, complete) {\n      super();\n      this.isStopped = false;\n      if (observerOrNext && typeof observerOrNext === 'object') {\n          this.destination = observerOrNext;\n      }\n      else {\n          this.destination = Object.assign(Object.assign(Object.assign({}, observerOrNext && { next: observerOrNext }), error && { error }), complete && { complete });\n      }\n  }\n  unsubscribe() {\n      if (this.closed) {\n          return;\n      }\n      this.isStopped = true;\n      super.unsubscribe();\n  }\n  next(value) {\n      if (!this.isStopped && this.destination.next) {\n          this.destination.next(value);\n      }\n  }\n  error(err) {\n      if (!this.isStopped && this.destination.error) {\n          this.isStopped = true;\n          this.destination.error(err);\n      }\n  }\n  complete(result) {\n      if (!this.isStopped && this.destination.complete) {\n          this.isStopped = true;\n          this.destination.complete(result);\n      }\n  }\n}\n/** 可观察对象，当前的上传事件的集合 */\nexport class Observable {\n  constructor(_subscribe) {\n      this._subscribe = _subscribe;\n  }\n  subscribe(observerOrNext, error, complete) {\n      const sink = new Subscriber(observerOrNext, error, complete);\n      sink.add(this._subscribe(sink));\n      return sink;\n  }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(0);\n"],"sourceRoot":""}